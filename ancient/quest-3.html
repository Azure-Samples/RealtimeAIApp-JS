<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Keeper of Real-Time Wisdom - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "tk53e05gf2");
    </script>
    
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }

        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-ancient">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/danwahlin/RealtimeAIApp-JS" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Temple of Echoes: Ancient Wisdom Unveiled</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Adventure</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Keeper of Real-Time Wisdom</h1>
<hr>
<p>In the Temple of Echoes, the Keeper of Real-Time Wisdom stands as the guardian of seamless communication between mortals and the divine. The sacred Trade Routes hum with energy, processing prayers and delivering the gods&#39; responses with the speed of thought. To understand the Keeper&#39;s secrets, you must delve into the Ritual of Connection, the Dance of Messages, and the Song of Audio Streams. These ancient rites will reveal how the temple achieves real-time communion, ensuring the wisdom of the gods flows continuously.</p>
<h2>Key Takeaways</h2>
<p>After completing this quest, you will understand:</p>
<ul>
<li>üéØ <strong>WebSocket Communication Flow</strong>: How the client establishes and manages real-time connections with the server.</li>
<li>üîç <strong>Reactive State Management</strong>: How RxJS BehaviorSubjects are used to track and update connection, audio, and session states.</li>
<li>‚ö° <strong>Message Handling Patterns</strong>: How incoming WebSocket messages are parsed, categorized, and processed for real-time updates.</li>
<li>üí° <strong>Audio Streaming Integration</strong>: How audio recording and playback are synchronized with WebSocket communication.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">client/src/app/core/web-socket.service.ts</code></a></h3>
<p>The <code class="inline-code">WebSocketService</code> is the sacred Trade Route that connects the temple&#39;s chambers to the divine realms. It establishes and manages the WebSocket connection, ensuring messages are sent and received in harmony. This service handles binary and text data, manages connection state, and gracefully recovers from errors.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L27" target="_blank" rel="noopener noreferrer"><code class="inline-code">connect</code></a>: Establishes the WebSocket connection and sends the initial system message to configure the session.</li>
<li><code class="inline-code">handleError</code>: Captures and propagates errors to ensure the system remains stable.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L74" target="_blank" rel="noopener noreferrer"><code class="inline-code">send</code></a>: Sends messages over the WebSocket, ensuring they are only transmitted when the connection is open.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L80" target="_blank" rel="noopener noreferrer"><code class="inline-code">close</code></a>: Closes the WebSocket and resets internal state for a clean disconnection.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">connect(url: string, systemMessageType: SystemMessageType) {
  if (this.socket) this.close();

  this.socket = new WebSocket(url);
  this.socket.binaryType = &#39;arraybuffer&#39;;

  this.socket.onopen = () =&gt; {
    this._isConnected.next(true);
    this.send({
      type: &#39;text&#39;,
      data: JSON.stringify({ type: &#39;init&#39;, systemMessageType })
    });
  };
  this.socket.onclose = () =&gt; this._isConnected.next(false);
  this.socket.onerror = (event: Event) =&gt; {
    const error = (event as ErrorEvent).error || new Error(&#39;WebSocket error&#39;);
    this.handleError(error);
  };

  this.socket.onmessage = (event: MessageEvent) =&gt; {
    const message: WebSocketMessage = {
      type: event.data instanceof ArrayBuffer ? &#39;binary&#39; : &#39;text&#39;,
      data: event.data
    };
    this.messageQueue.push(message);
    this._message.next(message);
  };
}
</code></pre>
<ul>
<li>This code establishes the WebSocket connection and sends an initialization message to configure the session.</li>
<li>The <code class="inline-code">onopen</code> event triggers the sending of the <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/player.service.ts#L11" target="_blank" rel="noopener noreferrer"><code class="inline-code">init</code></a> message, setting the session type (e.g., language coach or medical form).</li>
<li>Binary and text message handling ensures compatibility with both audio and text data.</li>
<li>Error handling captures connection issues and propagates them for visibility.</li>
</ul>
<hr>
<pre><code class="language-typescript">close() {
  this.socket?.close();
  this.socket = null;
  this.messageQueue = [];
  this.hasError = false;
  this._isConnected.next(false);

  // Instead of completing the subjects, recreate them
  this._errors = new Subject&lt;Error&gt;();
  this._message = new Subject&lt;WebSocketMessage&gt;();

  // Update the exposed observables to reference the new subjects
  this.errors$ = this._errors.asObservable();
  this.messages$ = this._message.asObservable();
}
</code></pre>
<ul>
<li>The <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L80" target="_blank" rel="noopener noreferrer"><code class="inline-code">close</code></a> method ensures a clean disconnection by resetting the WebSocket and internal state.</li>
<li>Subjects are recreated to avoid completing observables, which allows reconnection without reinitializing the service.</li>
<li>This approach ensures the system can recover from disconnections gracefully.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/realtime-manager.service.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">client/src/app/core/realtime-manager.service.ts</code></a></h3>
<p>The <code class="inline-code">RealTimeManagerService</code> acts as the Keeper of Real-Time Wisdom, orchestrating the flow of messages and audio streams. It manages connection state, handles WebSocket messages, and coordinates audio recording and playback to maintain harmony.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L27" target="_blank" rel="noopener noreferrer"><code class="inline-code">connect</code></a>: Initiates the WebSocket connection and sets up subscriptions for state management.</li>
<li><code class="inline-code">handleWebSocketMessage</code>: Processes incoming messages, handling both text and binary data.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/realtime-manager.service.ts#L132" target="_blank" rel="noopener noreferrer"><code class="inline-code">toggleRecording</code></a>: Manages the start and stop of audio recording based on the connection state.</li>
<li><code class="inline-code">handleWSMessage</code>: Categorizes and processes WebSocket messages, updating the UI with real-time changes.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">async connect(systemMessageType: SystemMessageType) {
  if (this._connectionState.value === &#39;connected&#39;) {
    await this.disconnect();
    return;
  }

  if (!this.playerService.initialized) {
    this.playerService.init(24000);
  }

  this._connectionState.next(&#39;connecting&#39;);
  try {
    this.initializeSubscriptions();
    await this.webSocketService.connect(this.endpoint, systemMessageType);
    // Session creation will trigger &#39;connected&#39; state via subscription
  } catch (error) {
    this.logError(&#39;Connection failed:&#39;, error);
    this._connectionState.next(&#39;disconnected&#39;);
  }
}
</code></pre>
<ul>
<li>This method initiates the WebSocket connection and prepares the system for real-time communication.</li>
<li>The <code class="inline-code">initializeSubscriptions</code> function sets up reactive state management for connection, session, and message handling.</li>
<li>Error handling ensures the system remains stable even if the connection fails.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async handleWSMessage(message: WSMessage) {
  switch (message.type) {
    case &#39;transcription&#39;:
      if (message.id &amp;&amp; this.currentUserMessageId === message.id) {
        const msg = this.messageMap.get(message.id);
        if (msg) {
          msg.content = message.text!;
          this._messages.next(Array.from(this.messageMap.values()));
        }
      }
      break;
    case &#39;text_delta&#39;:
      if (message.id) {
        const existingMessage = this.messageMap.get(message.id);
        if (existingMessage) {
          existingMessage.content += message.delta!;
        } else {
          const newMessage: Message = {
            id: message.id,
            type: &#39;assistant&#39;,
            content: message.delta!,
          };
          this.messageMap.set(message.id, newMessage);
        }
        this._messages.next(Array.from(this.messageMap.values()));
      }
      break;
    case &#39;control&#39;:
      // Handles session creation, errors, and other control messages
      break;
  }
}
</code></pre>
<ul>
<li>This method processes incoming WebSocket messages, categorizing them into transcription, text updates, and control actions.</li>
<li>It uses a <code class="inline-code">messageMap</code> to manage message state efficiently, ensuring real-time updates are reflected in the UI.</li>
<li>Control messages handle session creation, error reporting, and other critical events.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Reactive programming with RxJS can simplify state management. Study how <code class="inline-code">BehaviorSubject</code> is used to track and emit state changes.</li>
<li>WebSocket error handling is critical for stability. Notice how errors are captured and propagated in <code class="inline-code">handleError</code>.</li>
<li>Audio integration requires careful synchronization. Observe how recording and playback are managed in tandem with WebSocket communication.</li>
</ul>
<h2>Try This</h2>
<p>Challenge yourself to deepen your understanding:</p>
<ol>
<li><p><strong>Extend Message Handling</strong>: Add a new message type (e.g., <code class="inline-code">rate_limits_updated</code>) to the <code class="inline-code">handleWSMessage</code> method. Update the UI to display rate limit information when this message is received.</p>
</li>
<li><p><strong>Trace Audio Flow</strong>: Add logging to the <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/realtime-manager.service.ts#L132" target="_blank" rel="noopener noreferrer"><code class="inline-code">toggleRecording</code></a> and <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/realtime-manager.service.ts#L165" target="_blank" rel="noopener noreferrer"><code class="inline-code">handleAudioRecord</code></a> methods to trace the complete audio flow from recording to WebSocket transmission. Observe how audio data is processed and sent.</p>
</li>
<li><p><strong>Simulate Disconnection</strong>: Modify the <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L27" target="_blank" rel="noopener noreferrer"><code class="inline-code">connect</code></a> method to simulate a disconnection after a few seconds. Study how the system recovers and ensure the reconnection logic works as expected.</p>
</li>
</ol>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries of the temple&#39;s ancient technologies.</p>
<p>Hark, Keeper of Real-Time Wisdom, thou hast unlocked sacred truths upon the celestial path, advancing thy noble quest by 40%‚Äîlet the stars sing thy triumph and the ancient temples echo thy valor! ‚≠ê‚ö°üíé</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>