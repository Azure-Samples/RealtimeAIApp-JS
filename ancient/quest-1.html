<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Chamber of Sacred Trade Routes - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "tk53e05gf2");
    </script>
    
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }

        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-ancient">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/danwahlin/RealtimeAIApp-JS" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Temple of Echoes: Ancient Wisdom Unveiled</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Adventure</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 1: The Chamber of Sacred Trade Routes</h1>
<hr>
<p>Hidden deep within the Jungle of Azure lies the Temple of Echoes, where the Chamber of Sacred Trade Routes hums with ancient wisdom. This chamber is the heart of divine communication, connecting mortals to the gods through sacred rituals. Here, the Whispering Glyphs translate prayers into divine messages, while the Trade Routes channel these messages across realms. Your task is to uncover the secrets of the chamber‚Äôs ancient mechanisms and master the art of real-time communication with the divine.</p>
<h2>Key Takeaways</h2>
<p>After completing this quest, you will understand:</p>
<ul>
<li>üéØ <strong>WebSocket Upgrade Handling</strong>: How HTTP requests are transformed into WebSocket connections for real-time communication.</li>
<li>üîç <strong>Session Lifecycle Management</strong>: The importance of initializing, maintaining, and disposing of WebSocket sessions effectively.</li>
<li>‚ö° <strong>Audio Buffering Strategies</strong>: Techniques for batching and streaming audio data efficiently to manage backpressure.</li>
<li>üí° <strong>Event-Driven Architecture</strong>: How event handlers manage incoming and outgoing messages between client and server.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/server.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">server/src/server.ts</code></a></h3>
<p>The Chamber of Sacred Trade Routes begins with the <code class="inline-code">server.ts</code> file, which acts as the gateway to the temple. This file handles WebSocket connections, ensuring that the sacred Trade Routes are properly established. It relies on HTTP upgrades to initiate WebSocket sessions, and carefully manages incoming client connections to ensure the rituals proceed seamlessly.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">server.on(&#39;upgrade&#39;)</code>: Transforms HTTP requests into WebSocket connections, validating paths and initiating upgrades.</li>
<li><code class="inline-code">wss.on(&#39;connection&#39;)</code>: Establishes a new session for each client, ensuring proper lifecycle management.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/server.ts#L39" target="_blank" rel="noopener noreferrer"><code class="inline-code">handleSocketEvent</code></a>: Processes WebSocket events, including initialization and error handling.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">server.on(&#39;upgrade&#39;, (request, socket, head) =&gt; {
  const { pathname } = new URL(request.url!, `http://${request.headers.host}`);
  if (pathname === &#39;/realtime&#39;) {
    logger.debug({ pathname }, &#39;Handling WebSocket upgrade request&#39;);
    wss.handleUpgrade(request, socket, head, (ws) =&gt; {
      logger.debug(&#39;WebSocket upgrade successful&#39;);
      wss.emit(&#39;connection&#39;, ws, request);
    });
  } else {
    logger.warn({ pathname }, &#39;Invalid WebSocket path - destroying connection&#39;);
    socket.destroy();
  }
});
</code></pre>
<ul>
<li>This code transforms HTTP upgrade requests into WebSocket connections at the <code class="inline-code">/realtime</code> endpoint.</li>
<li>Path validation ensures only authorized routes are upgraded, preventing misuse.</li>
<li>The <code class="inline-code">handleUpgrade</code> method establishes a WebSocket connection for further communication.</li>
</ul>
<hr>
<pre><code class="language-typescript">wss.on(&#39;connection&#39;, (ws: WebSocket) =&gt; {
  logger.info(&#39;üü¢ New Client websocket connection opened&#39;);
  let rtSession: RTSession | null = null;

  const handleSocketEvent = (eventType: string, data?: any) =&gt; {
    switch (eventType) {
      case &#39;message&#39;:
        if (!data) {
          logger.warn(&#39;Received empty message&#39;);
          return;
        }

        try {
          const messageText = data.toString();
          const initSystemMessage = JSON.parse(messageText);

          if (initSystemMessage.type === &#39;init&#39;) {
            if (rtSession) {
              logger.warn(&#39;üü† RTSession already exists - ignoring duplicate init&#39;);
              return;
            }

            logger.info(&#39;üîÑ Initializing RTSession&#39;);
            const systemMessage = getSystemMessage(initSystemMessage.systemMessageType);
            logger.info({ systemMessage }, &#39;‚úÖ System message retrieved&#39;);
            
            rtSession = new RTSession(ws, logger, systemMessage);
            ws.off(&#39;message&#39;, messageHandler);
          }
        } catch (error) {
          logger.error({ error, message: data.toString() }, &#39;üî• Failed to process message&#39;);
        }
        break;

      case &#39;error&#39;:
        logger.error({ error: data }, &#39;üî• WebSocket error occurred&#39;);
        rtSession?.dispose();
        rtSession = null;
        break;

      case &#39;close&#39;:
        logger.info(&#39;üî¥ WebSocket connection closed&#39;);
        rtSession?.dispose();
        rtSession = null;
        break;
    }
  };

  const messageHandler = (message: any) =&gt; handleSocketEvent(&#39;message&#39;, message);

  ws.on(&#39;message&#39;, messageHandler);
  ws.on(&#39;error&#39;, (error: Error) =&gt; handleSocketEvent(&#39;error&#39;, error));
  ws.on(&#39;close&#39;, () =&gt; handleSocketEvent(&#39;close&#39;));
});
</code></pre>
<ul>
<li>The <code class="inline-code">connection</code> event initializes a new WebSocket session for each client.</li>
<li>Lifecycle management ensures sessions are properly created and disposed of when connections close.</li>
<li>The <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/server.ts#L39" target="_blank" rel="noopener noreferrer"><code class="inline-code">handleSocketEvent</code></a> function processes messages, errors, and closure events, maintaining stability.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/session.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">server/src/session.ts</code></a></h3>
<p>The <code class="inline-code">session.ts</code> file represents the sacred rituals performed within the Chamber. It manages WebSocket communication with the divine OpenAI API, orchestrating the flow of audio and text messages. This file demonstrates advanced techniques for buffering, batching, and handling real-time events.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">RTSession.constructor</code>: Initializes a session with client and OpenAI WebSocket connections, setting up sacred instructions.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/session.ts#L131" target="_blank" rel="noopener noreferrer"><code class="inline-code">initializeRealtimeWebSocket</code></a>: Establishes a connection to the OpenAI Realtime API, handling authentication and configuration.</li>
<li><code class="inline-code">flushAudioBuffer</code>: Batches audio data for efficient streaming, managing backpressure and ensuring smooth communication.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">constructor(
  private readonly clientWs: WebSocket,
  private readonly logger: Logger,
  private systemMessage: SystemMessage | null
) {
  if (!this.systemMessage) throw new Error(&#39;üî• System message is required&#39;);

  this.logger = logger.child({ sessionId: this.sessionId });
  this.logger.info({ message: this.systemMessage.message }, &#39;‚úÖ Init message received&#39;);
  this.initialize().catch((error) =&gt; this.logger.error({ error }, &#39;üî• Failed to initialize session&#39;));
}
</code></pre>
<ul>
<li>The constructor initializes the session, setting up sacred instructions from the system message.</li>
<li>It validates the presence of a system message, ensuring the session begins with proper guidance.</li>
<li>Logging provides insights into session initialization progress.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async initializeRealtimeWebSocket(): Promise&lt;WebSocket&gt; {
  const url = BACKEND === &#39;azure&#39;
    ? `${OPENAI_ENDPOINT.replace(&#39;https://&#39;, &#39;wss://&#39;)}/openai/realtime?deployment=${OPENAI_MODEL}&amp;api-version=${OPENAI_API_VERSION}`
    : this.openAIWsUrl;

  this.logger.info(`üîå Connecting to OpenAI WebSocket at ${url}`);

  return new Promise(async (resolve, reject) =&gt; {
    const headers = await this.getWebSocketHeaders();
    const openAIWs = new WebSocket(url, { headers });

    openAIWs.on(&#39;open&#39;, () =&gt; {
      this.logger.info(&#39;üü¢ OpenAI WebSocket connection opened&#39;);
      resolve(openAIWs);
    });

    openAIWs.on(&#39;error&#39;, (error) =&gt; {
      console.log(error);
      reject(error);
    });
  });
}
</code></pre>
<ul>
<li>This method establishes a WebSocket connection to OpenAI, dynamically selecting Azure or OpenAI based on configuration.</li>
<li>Authentication headers are generated using API keys or managed identity tokens.</li>
<li>The connection lifecycle is handled with event listeners for <code class="inline-code">open</code> and <code class="inline-code">error</code>.</li>
</ul>
<hr>
<pre><code class="language-typescript">private flushAudioBuffer() {
  this.audioBufferTimer = null;

  if (this.audioBufferQueue.length === 0) return;
  if (!this.openAIWs || this.openAIWs.readyState !== WebSocket.OPEN) {
    this.clearAudioQueue();
    return;
  }

  try {
    const totalSize = this.currentBufferSize;
    const combinedBuffer = this.combineAudioBuffers(totalSize);

    this.clearAudioQueue();

    const sendStart = performance.now();
    this.sendAudioToOpenAI(combinedBuffer, totalSize);
    const sendDuration = performance.now() - sendStart;

    this.updateAudioMetrics(totalSize, sendDuration);
  } catch (error) {
    this.logger.error({ error }, &#39;üî• Error while flushing audio buffer&#39;);
    this.clearAudioQueue();
  }
}
</code></pre>
<ul>
<li>The <code class="inline-code">flushAudioBuffer</code> method batches and sends audio data to OpenAI, ensuring efficient transmission.</li>
<li>Backpressure handling prevents overloading the WebSocket connection.</li>
<li>Metrics are updated to track performance and identify bottlenecks.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Study how <code class="inline-code">server.on(&#39;upgrade&#39;)</code> handles HTTP upgrades to WebSocket connections, ensuring secure initialization.</li>
<li>Observe the lifecycle management in <code class="inline-code">RTSession</code> to maintain stability across sessions.</li>
<li>Explore the techniques used in <code class="inline-code">flushAudioBuffer</code> for batching and streaming audio data efficiently.</li>
</ul>
<h2>Try This</h2>
<p>Challenge yourself to deepen your understanding:</p>
<ol>
<li><strong>Modify Connection Lifecycle</strong>: Add additional logging to track WebSocket connection states. Observe how the system handles errors and disconnections.</li>
<li><strong>Experiment with Audio Buffering</strong>: Adjust the <code class="inline-code">MAX_BUFFER_SIZE</code> and <code class="inline-code">BATCH_INTERVAL_MS</code> values in <code class="inline-code">session.ts</code>. Measure the impact on audio transmission performance.</li>
<li><strong>Implement Custom System Messages</strong>: Create a new system message type in <code class="inline-code">systemMessages.ts</code> and test its integration by sending an <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/player.service.ts#L11" target="_blank" rel="noopener noreferrer"><code class="inline-code">init</code></a> message from the client.</li>
</ol>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries of the Temple of Echoes.</p>
<p>Hail, seeker of wisdom, for thou hast unveiled the ancient truths of The Chamber of Sacred Trade Routes‚Äîlet thy triumph shine as a beacon upon the sacred map of destiny! ‚≠êüó∫Ô∏è‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom nav-next-only">
        <a href="quest-2.html" class="next-quest-btn">Next: Quest 2 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>