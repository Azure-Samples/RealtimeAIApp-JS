<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebSocket Server & Session Management - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "tk53e05gf2");
    </script>
    
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }

        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-developer">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/danwahlin/RealtimeAIApp-JS" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Real-Time AI Integration Guide</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Adventure</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 1: WebSocket Server &amp; Session Management</h1>
<hr>
<p>Dive into the heart of real-time communication with WebSocket technology! This quest explores how the server establishes, manages, and orchestrates WebSocket connections to enable seamless bidirectional communication between the client and OpenAI&#39;s Realtime API. By understanding the WebSocket upgrade process, RTSession creation, and audio buffering mechanisms, you&#39;ll uncover the technical magic behind real-time AI applications.</p>
<h2>Key Takeaways</h2>
<p>After completing this quest, you will understand:</p>
<ul>
<li>üéØ <strong>WebSocket Upgrade Flow</strong>: How the server handles WebSocket upgrade requests and establishes connections.</li>
<li>üîç <strong>Session Lifecycle Management</strong>: How RTSession manages client and OpenAI WebSocket connections.</li>
<li>‚ö° <strong>Audio Buffering</strong>: Techniques for batching and transmitting audio data efficiently.</li>
<li>üí° <strong>Error Handling Patterns</strong>: How the system ensures stability during WebSocket and API failures.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/server.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">server/src/server.ts</code></a></h3>
<p>The <code class="inline-code">server.ts</code> file acts as the entry point for the backend, initializing the Express server and managing WebSocket upgrade requests. It uses the <code class="inline-code">WebSocketServer</code> to handle real-time connections, ensuring smooth communication between the client and RTSession. This file highlights critical patterns for WebSocket setup and lifecycle management.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">server.on(&#39;upgrade&#39;)</code>: Handles HTTP requests to upgrade them to WebSocket connections for real-time communication.</li>
<li><code class="inline-code">wss.on(&#39;connection&#39;)</code>: Manages new WebSocket connections, initializing RTSession instances.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/server.ts#L39" target="_blank" rel="noopener noreferrer"><code class="inline-code">handleSocketEvent</code></a>: Processes WebSocket events like <code class="inline-code">message</code>, <code class="inline-code">error</code>, and <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L80" target="_blank" rel="noopener noreferrer"><code class="inline-code">close</code></a>.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">server.on(&#39;upgrade&#39;, (request, socket, head) =&gt; {
  const { pathname } = new URL(request.url!, `http://${request.headers.host}`);
  if (pathname === &#39;/realtime&#39;) {
    logger.debug({ pathname }, &#39;Handling WebSocket upgrade request&#39;);
    wss.handleUpgrade(request, socket, head, (ws) =&gt; {
      logger.debug(&#39;WebSocket upgrade successful&#39;);
      wss.emit(&#39;connection&#39;, ws, request);
    });
  } else {
    logger.warn({ pathname }, &#39;Invalid WebSocket path - destroying connection&#39;);
    socket.destroy();
  }
});
</code></pre>
<ul>
<li>Handles WebSocket upgrade requests, ensuring only valid paths (<code class="inline-code">/realtime</code>) are accepted.</li>
<li>Uses <code class="inline-code">wss.handleUpgrade</code> to process the WebSocket handshake and establish connections.</li>
<li>Logs critical events for debugging and monitoring.</li>
</ul>
<hr>
<pre><code class="language-typescript">wss.on(&#39;connection&#39;, (ws: WebSocket) =&gt; {
  logger.info(&#39;üü¢ New Client websocket connection opened&#39;);
  let rtSession: RTSession | null = null;

  const handleSocketEvent = (eventType: string, data?: any) =&gt; {
    switch (eventType) {
      case &#39;message&#39;:
        if (!data) {
          logger.warn(&#39;Received empty message&#39;);
          return;
        }
        try {
          const messageText = data.toString();
          const initSystemMessage = JSON.parse(messageText);

          if (initSystemMessage.type === &#39;init&#39;) {
            if (rtSession) {
              logger.warn(&#39;üü† RTSession already exists - ignoring duplicate init&#39;);
              return;
            }
            logger.info(&#39;üîÑ Initializing RTSession&#39;);
            const systemMessage = getSystemMessage(initSystemMessage.systemMessageType);
            rtSession = new RTSession(ws, logger, systemMessage);
            ws.off(&#39;message&#39;, messageHandler);
          }
        } catch (error) {
          logger.error({ error, message: data.toString() }, &#39;üî• Failed to process message&#39;);
        }
        break;

      case &#39;error&#39;:
        logger.error({ error: data }, &#39;üî• WebSocket error occurred&#39;);
        rtSession?.dispose();
        rtSession = null;
        break;

      case &#39;close&#39;:
        logger.info(&#39;üî¥ WebSocket connection closed&#39;);
        rtSession?.dispose();
        rtSession = null;
        break;
    }
  };

  const messageHandler = (message: any) =&gt; handleSocketEvent(&#39;message&#39;, message);

  ws.on(&#39;message&#39;, messageHandler);
  ws.on(&#39;error&#39;, (error: Error) =&gt; handleSocketEvent(&#39;error&#39;, error));
  ws.on(&#39;close&#39;, () =&gt; handleSocketEvent(&#39;close&#39;));
});
</code></pre>
<ul>
<li>Establishes RTSession for each new WebSocket connection, handling initialization messages.</li>
<li>Uses defensive programming to prevent duplicate session creation.</li>
<li>Cleans up resources and logs events when connections are closed or errors occur.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/session.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">server/src/session.ts</code></a></h3>
<p>The <code class="inline-code">session.ts</code> file defines the <code class="inline-code">RTSession</code> class, which manages communication between the client WebSocket and OpenAI Realtime API. It includes advanced features like audio buffering, session initialization, and event handling.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">RTSession.constructor</code>: Initializes the session with client WebSocket, logger, and system message.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/session.ts#L131" target="_blank" rel="noopener noreferrer"><code class="inline-code">initializeRealtimeWebSocket</code></a>: Establishes a connection to OpenAI or Azure OpenAI Realtime API.</li>
<li><code class="inline-code">flushAudioBuffer</code>: Manages audio buffering and transmission to OpenAI.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">constructor(
  private readonly clientWs: WebSocket,
  private readonly logger: Logger,
  private systemMessage: SystemMessage | null
) {
  if (!this.systemMessage) throw new Error(&#39;üî• System message is required&#39;);

  this.logger = logger.child({ sessionId: this.sessionId });
  this.logger.info({ message: this.systemMessage.message }, &#39;‚úÖ Init message received&#39;);
  this.initialize().catch((error) =&gt; this.logger.error({ error }, &#39;üî• Failed to initialize session&#39;));
}
</code></pre>
<ul>
<li>Validates the presence of a system message during session creation.</li>
<li>Logs initialization details for debugging.</li>
<li>Calls <code class="inline-code">initialize</code> to set up the OpenAI WebSocket connection.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async initializeRealtimeWebSocket(): Promise&lt;WebSocket&gt; {
  const url = BACKEND === &#39;azure&#39;
    ? `${OPENAI_ENDPOINT.replace(&#39;https://&#39;, &#39;wss://&#39;)}/openai/realtime?deployment=${OPENAI_MODEL}&amp;api-version=${OPENAI_API_VERSION}`
    : this.openAIWsUrl;

  this.logger.info(`üîå Connecting to OpenAI WebSocket at ${url}`);

  return new Promise(async (resolve, reject) =&gt; {
    const headers = await this.getWebSocketHeaders();
    const openAIWs = new WebSocket(url, { headers });

    openAIWs.on(&#39;open&#39;, () =&gt; {
      this.logger.info(&#39;üü¢ OpenAI WebSocket connection opened&#39;);
      resolve(openAIWs);
    });

    openAIWs.on(&#39;error&#39;, (error) =&gt; {
      reject(error);
    });
  });
}
</code></pre>
<ul>
<li>Dynamically constructs the WebSocket URL based on the backend configuration (Azure or OpenAI).</li>
<li>Implements error handling to manage connection failures.</li>
<li>Uses async/await for clean asynchronous operations.</li>
</ul>
<hr>
<pre><code class="language-typescript">private flushAudioBuffer() {
  this.audioBufferTimer = null;

  if (this.audioBufferQueue.length === 0) return;
  if (!this.openAIWs || this.openAIWs.readyState !== WebSocket.OPEN) {
    this.clearAudioQueue();
    return;
  }

  try {
    const bufferedAmount = (this.openAIWs as any)._socket?.bufferedAmount || 0;
    if (this.handleBackpressure(bufferedAmount)) return;

    const totalSize = this.currentBufferSize;
    const combinedBuffer = this.combineAudioBuffers(totalSize);

    this.clearAudioQueue();

    const sendStart = performance.now();
    this.sendAudioToOpenAI(combinedBuffer, totalSize);
    const sendDuration = performance.now() - sendStart;

    this.updateAudioMetrics(totalSize, sendDuration);
  } catch (error) {
    this.logger.error({ error }, &#39;üî• Error while flushing audio buffer&#39;);
    this.clearAudioQueue();
  }
}
</code></pre>
<ul>
<li>Combines audio buffers and sends them to OpenAI in batches to optimize performance.</li>
<li>Implements backpressure handling to prevent WebSocket overload.</li>
<li>Logs metrics for analysis and debugging.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Study how <code class="inline-code">server.on(&#39;upgrade&#39;)</code> validates WebSocket paths to ensure secure communication.</li>
<li>Observe how <code class="inline-code">RTSession</code> uses dynamic headers for Azure and OpenAI authentication.</li>
<li>Explore the <code class="inline-code">flushAudioBuffer</code> method to understand audio batching techniques.</li>
</ul>
<h2>Try This</h2>
<p>Challenge yourself to deepen your understanding:</p>
<ol>
<li><strong>Add Custom Logging</strong>: Enhance the logging in <code class="inline-code">flushAudioBuffer</code> to include buffer sizes and send durations. This will help you analyze audio transmission performance.</li>
<li><strong>Simulate Backpressure</strong>: Modify <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/session.ts#L488" target="_blank" rel="noopener noreferrer"><code class="inline-code">handleBackpressure</code></a> to simulate high WebSocket traffic. Observe how the system handles dropped audio chunks and adjusts buffer sizes.</li>
<li><strong>Implement Session Metrics</strong>: Extend <code class="inline-code">RTSession</code> to log session duration and average response latency. Use these metrics to monitor real-time performance.</li>
</ol>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries of this real-time AI application.</p>
<p>Achievement unlocked: You&#39;ve architected a rock-solid WebSocket Server with seamless session management‚Äîyour codebase is now a real-time powerhouse! üöÄ‚ö°üíé</p>

</div>


      <div class="quest-navigation quest-navigation-bottom nav-next-only">
        <a href="quest-2.html" class="next-quest-btn">Next: Quest 2 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>