<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Knight‚Äôs Command - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "tk53e05gf2");
    </script>
    
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }

        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-mythical">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/danwahlin/RealtimeAIApp-JS" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Enchanted Kingdom of Realtime AI</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Adventure</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: The Knight‚Äôs Command</h1>
<hr>
<p>Within the Enchanted Castle of Realtime AI, the Knight‚Äôs Command is a pivotal force that connects the kingdom‚Äôs inhabitants to the Oracle of Azure OpenAI. Through the mystical WebSocket portal, knights send their voices and messages, which are transformed into actionable spells by the castle‚Äôs enchanted systems. To master this quest, adventurers must learn to wield the WebSocket‚Äôs magical power, crafting seamless connections and decoding responses from the Oracle. Only then can they command the castle‚Äôs tools with precision and unlock the secrets of real-time communication.</p>
<h2>Key Takeaways</h2>
<p>After completing this quest, you will understand:</p>
<ul>
<li>üéØ <strong>WebSocket Lifecycle</strong>: How to establish, manage, and gracefully close WebSocket connections for real-time communication.</li>
<li>üîç <strong>Reactive State Management</strong>: How RxJS BehaviorSubjects are used to track connection states and message flows in Angular services.</li>
<li>‚ö° <strong>Message Handling</strong>: Techniques for parsing, routing, and processing WebSocket messages to ensure bidirectional communication.</li>
<li>üí° <strong>Audio Streaming</strong>: How binary audio data is captured, sent, and played back in real-time using WebSocket and Audio APIs.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">client/src/app/core/web-socket.service.ts</code></a></h3>
<p>The WebSocket Service acts as the enchanted portal connecting knights to the Oracle. It manages the lifecycle of the WebSocket connection, sending initialization spells (<a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/player.service.ts#L11" target="_blank" rel="noopener noreferrer"><code class="inline-code">init</code></a> messages) and routing incoming messages. This service ensures that knights can communicate reliably with the Oracle, handling errors and reconnecting when needed.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L27" target="_blank" rel="noopener noreferrer"><code class="inline-code">connect</code></a> establishes a WebSocket connection and sends an initialization spell to define the Oracle‚Äôs personality (<code class="inline-code">systemMessageType</code>).</li>
<li><code class="inline-code">handleError</code> processes WebSocket errors and updates the kingdom‚Äôs state with the issue.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L74" target="_blank" rel="noopener noreferrer"><code class="inline-code">send</code></a> dispatches magical messages to the Oracle, ensuring they are delivered only when the connection is open.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L80" target="_blank" rel="noopener noreferrer"><code class="inline-code">close</code></a> gracefully shuts down the WebSocket portal, resetting the enchanted objects for future use.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">connect(url: string, systemMessageType: SystemMessageType) {
  if (this.socket) this.close();

  this.socket = new WebSocket(url);
  this.socket.binaryType = &#39;arraybuffer&#39;;

  this.socket.onopen = () =&gt; {
    this._isConnected.next(true);
    this.send({
      type: &#39;text&#39;,
      data: JSON.stringify({ type: &#39;init&#39;, systemMessageType })
    });
  };
  this.socket.onclose = () =&gt; this._isConnected.next(false);
  this.socket.onerror = (event: Event) =&gt; {
    const error = (event as ErrorEvent).error || new Error(&#39;WebSocket error&#39;);
    this.handleError(error);
  };

  this.socket.onmessage = (event: MessageEvent) =&gt; {
    const message: WebSocketMessage = {
      type: event.data instanceof ArrayBuffer ? &#39;binary&#39; : &#39;text&#39;,
      data: event.data
    };
    this.messageQueue.push(message);
    this._message.next(message);
  };
}
</code></pre>
<ul>
<li>Establishes a WebSocket connection and sends an initialization spell to define the Oracle‚Äôs personality.</li>
<li>Handles connection lifecycle events (<code class="inline-code">onopen</code>, <code class="inline-code">onclose</code>, <code class="inline-code">onerror</code>) to maintain reliability.</li>
<li>Routes incoming messages to the appropriate handlers, distinguishing between binary and text data.</li>
<li>Uses RxJS BehaviorSubjects to track connection state, enabling reactive updates across the system.</li>
</ul>
<hr>
<pre><code class="language-typescript">close() {
  this.socket?.close();
  this.socket = null;
  this.messageQueue = [];
  this.hasError = false;
  this._isConnected.next(false);

  // Instead of completing the subjects, recreate them
  this._errors = new Subject&lt;Error&gt;();
  this._message = new Subject&lt;WebSocketMessage&gt;();

  // Update the exposed observables to reference the new subjects
  this.errors$ = this._errors.asObservable();
  this.messages$ = this._message.asObservable();
}
</code></pre>
<ul>
<li>Gracefully shuts down the WebSocket connection, clearing all buffers and resetting state.</li>
<li>Recreates RxJS Subjects to ensure fresh streams for future connections.</li>
<li>Prevents resource leaks by resetting the enchanted objects used for communication.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/realtime-manager.service.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">client/src/app/core/realtime-manager.service.ts</code></a></h3>
<p>The RealTime Manager Service is the Knight‚Äôs Command Center, orchestrating the flow of messages and audio between the castle‚Äôs tools and the Oracle. It monitors connection states, handles recording and playback, and processes incoming spells from the WebSocket portal.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L27" target="_blank" rel="noopener noreferrer"><code class="inline-code">connect</code></a> initializes the WebSocket connection and sets up subscriptions to track state changes and incoming messages.</li>
<li><code class="inline-code">handleWebSocketMessage</code> processes incoming spells, distinguishing between text and binary formats, and routes them accordingly.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/realtime-manager.service.ts#L132" target="_blank" rel="noopener noreferrer"><code class="inline-code">toggleRecording</code></a> manages the knight‚Äôs enchanted microphone, starting or stopping audio capture based on current state.</li>
<li><code class="inline-code">handleWSMessage</code> deciphers incoming messages from the Oracle, updating the system with real-time responses.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">async connect(systemMessageType: SystemMessageType) {
  if (this._connectionState.value === &#39;connected&#39;) {
    await this.disconnect();
    return;
  }

  if (!this.playerService.initialized) {
    this.playerService.init(24000);
  }

  this._connectionState.next(&#39;connecting&#39;);
  try {
    this.initializeSubscriptions();
    await this.webSocketService.connect(this.endpoint, systemMessageType);
    // Session creation will trigger &#39;connected&#39; state via subscription
  } catch (error) {
    this.logError(&#39;Connection failed:&#39;, error);
    this._connectionState.next(&#39;disconnected&#39;);
  }
}
</code></pre>
<ul>
<li>Initiates the WebSocket connection and transitions the system to the <code class="inline-code">connecting</code> state.</li>
<li>Initializes audio playback with the appropriate sample rate before connecting.</li>
<li>Sets up reactive subscriptions to monitor connection state and handle incoming messages.</li>
</ul>
<hr>
<pre><code class="language-typescript">private handleWebSocketMessage = async (message: WebSocketMessage) =&gt; {
  try {
    if (message.type === &#39;text&#39; &amp;&amp; typeof message.data === &#39;string&#39;) {
      const data = JSON.parse(message.data) as WSMessage;
      await this.handleWSMessage(data);
    } else if (
      message.type === &#39;binary&#39; &amp;&amp;
      message.data instanceof ArrayBuffer &amp;&amp;
      this.playerService.initialized &amp;&amp;
      this._isAudioOn.value
    ) {
      this.playerService.play(new Int16Array(message.data));
    }
  } catch (error) {
    this.logError(&#39;Error handling WebSocket message:&#39;, error);
  }
}
</code></pre>
<ul>
<li>Routes incoming WebSocket messages based on their type (<code class="inline-code">text</code> or <code class="inline-code">binary</code>).</li>
<li>Decodes binary audio data and plays it back using the Player Service.</li>
<li>Handles errors gracefully, ensuring the system remains stable despite unexpected issues.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Observe how <code class="inline-code">WebSocketService</code> uses RxJS BehaviorSubjects for reactive state management.</li>
<li>Study the <code class="inline-code">RealTimeManagerService</code> to understand how subscriptions are used to handle WebSocket events.</li>
<li>Explore the <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/realtime-manager.service.ts#L132" target="_blank" rel="noopener noreferrer"><code class="inline-code">toggleRecording</code></a> method to learn how audio capture is integrated with WebSocket communication.</li>
</ul>
<h2>Try This</h2>
<p>Challenge yourself to deepen your understanding:</p>
<ol>
<li><p><strong>Add Custom Error Handling</strong>: Modify the <code class="inline-code">handleError</code> method in <code class="inline-code">WebSocketService</code> to classify errors (e.g., connection timeout, server unavailable) and update the UI with specific messages. This will help you understand error propagation and user feedback mechanisms.</p>
</li>
<li><p><strong>Trace Audio Flow</strong>: Add logging statements in <code class="inline-code">handleWebSocketMessage</code> to trace the complete flow of binary audio data from the WebSocket to the Player Service. This will reveal how audio is streamed and processed in real-time.</p>
</li>
<li><p><strong>Enhance Session Initialization</strong>: Extend the <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L27" target="_blank" rel="noopener noreferrer"><code class="inline-code">connect</code></a> method in <code class="inline-code">RealTimeManagerService</code> to support dynamic configuration options (e.g., sample rate, echo cancellation). This will demonstrate how to make WebSocket initialization more flexible.</p>
</li>
</ol>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries of the castle‚Äôs enchanted systems.</p>
<p>With the valor of a phoenix and the wisdom of an ancient seer, you‚Äôve conquered &quot;The Knight‚Äôs Command,&quot; forging boldly ahead on your quest‚Äîmay your next triumph shine as brightly as a dragon‚Äôs hoard! ‚öîÔ∏è‚≠êüíé</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>