<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client-Side Real-Time Coordination - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "tk53e05gf2");
    </script>
    
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }

        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-developer">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/danwahlin/RealtimeAIApp-JS" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Real-Time AI Integration Guide</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Adventure</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 3: Client-Side Real-Time Coordination</h1>
<hr>
<p>The client application serves as the nerve center of real-time interaction, orchestrating seamless communication between the user and OpenAI&#39;s Realtime API. Using WebSocket-based messaging, it ensures low-latency audio streaming, message handling, and session management. With Angular services for recording, playback, and WebSocket communication, the client empowers developers to deliver responsive AI-driven experiences, whether for language learning or medical form assistance.</p>
<h2>Key Takeaways</h2>
<p>After completing this quest, you will understand:</p>
<ul>
<li>üéØ <strong>WebSocket Communication Flow</strong>: How WebSocket connections enable real-time data exchange between client and server.</li>
<li>üîç <strong>Reactive State Management</strong>: Using RxJS BehaviorSubjects for dynamic state tracking and observables for UI updates.</li>
<li>‚ö° <strong>Audio Handling Pipeline</strong>: How the client captures, processes, and streams audio data to the server.</li>
<li>üí° <strong>Error Resilience</strong>: Implementing robust error handling and recovery mechanisms for WebSocket connections.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">client/src/app/core/web-socket.service.ts</code></a></h3>
<p>The <code class="inline-code">WebSocketService</code> acts as the communication bridge between the client and server, managing the WebSocket connection lifecycle, message routing, and error handling. It supports both binary and text messages, ensuring compatibility with audio streaming and AI responses. The service uses RxJS subjects to propagate connection state and incoming messages, enabling reactive updates across the application.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L27" target="_blank" rel="noopener noreferrer"><code class="inline-code">connect</code></a>: Establishes a WebSocket connection and sends an initialization message.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L74" target="_blank" rel="noopener noreferrer"><code class="inline-code">send</code></a>: Sends binary or text messages through the WebSocket connection.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L80" target="_blank" rel="noopener noreferrer"><code class="inline-code">close</code></a>: Closes the WebSocket connection and resets internal states for reconnection.</li>
<li><code class="inline-code">handleError</code>: Captures and propagates WebSocket errors for debugging and recovery.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">connect(url: string, systemMessageType: SystemMessageType) {
  if (this.socket) this.close();

  this.socket = new WebSocket(url);
  this.socket.binaryType = &#39;arraybuffer&#39;;

  this.socket.onopen = () =&gt; {
    this._isConnected.next(true);
    this.send({
      type: &#39;text&#39;,
      data: JSON.stringify({ type: &#39;init&#39;, systemMessageType })
    });
  };
  this.socket.onclose = () =&gt; this._isConnected.next(false);
  this.socket.onerror = (event: Event) =&gt; {
    const error = (event as ErrorEvent).error || new Error(&#39;WebSocket error&#39;);
    this.handleError(error);
  };

  this.socket.onmessage = (event: MessageEvent) =&gt; {
    const message: WebSocketMessage = {
      type: event.data instanceof ArrayBuffer ? &#39;binary&#39; : &#39;text&#39;,
      data: event.data
    };
    this.messageQueue.push(message);
    this._message.next(message);
  };
}
</code></pre>
<ul>
<li>Establishes a WebSocket connection and sends an initialization message with the AI personality type.</li>
<li>Sets up event handlers for connection state, errors, and incoming messages.</li>
<li>Differentiates between binary and text message types for appropriate handling.</li>
<li>Demonstrates defensive programming by resetting the connection on error.</li>
</ul>
<hr>
<pre><code class="language-typescript">close() {
  this.socket?.close();
  this.socket = null;
  this.messageQueue = [];
  this.hasError = false;
  this._isConnected.next(false);

  this._errors = new Subject&lt;Error&gt;();
  this._message = new Subject&lt;WebSocketMessage&gt;();

  this.errors$ = this._errors.asObservable();
  this.messages$ = this._message.asObservable();
}
</code></pre>
<ul>
<li>Resets the WebSocket connection, clearing message queues and error states.</li>
<li>Recreates RxJS subjects to allow fresh observables for reconnection.</li>
<li>Ensures proper cleanup to prevent memory leaks or stale states.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/realtime-manager.service.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">client/src/app/core/realtime-manager.service.ts</code></a></h3>
<p>The <code class="inline-code">RealTimeManagerService</code> coordinates client-side operations, including WebSocket connection management, audio recording/playback, and reactive state updates. It tracks connection states, processes incoming WebSocket messages, and manages user interactions like starting/stopping audio recording and toggling playback.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L27" target="_blank" rel="noopener noreferrer"><code class="inline-code">connect</code></a>: Initializes WebSocket connection and subscribes to state changes.</li>
<li><code class="inline-code">handleWebSocketMessage</code>: Processes incoming WebSocket messages, including binary audio and text responses.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/realtime-manager.service.ts#L132" target="_blank" rel="noopener noreferrer"><code class="inline-code">toggleRecording</code></a>: Manages audio recording state based on connection status.</li>
<li><code class="inline-code">handleWSMessage</code>: Handles structured WebSocket messages like transcription, text deltas, and control actions.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">async connect(systemMessageType: SystemMessageType) {
  if (this._connectionState.value === &#39;connected&#39;) {
    await this.disconnect();
    return;
  }

  if (!this.playerService.initialized) {
    this.playerService.init(24000);
  }

  this._connectionState.next(&#39;connecting&#39;);
  try {
    this.initializeSubscriptions();
    await this.webSocketService.connect(this.endpoint, systemMessageType);
  } catch (error) {
    this.logError(&#39;Connection failed:&#39;, error);
    this._connectionState.next(&#39;disconnected&#39;);
  }
}
</code></pre>
<ul>
<li>Establishes a WebSocket connection while initializing audio playback services.</li>
<li>Uses RxJS BehaviorSubjects to track connection state and trigger UI updates.</li>
<li>Implements error handling to gracefully recover from connection failures.</li>
</ul>
<hr>
<pre><code class="language-typescript">private handleWebSocketMessage = async (message: WebSocketMessage) =&gt; {
  try {
    if (message.type === &#39;text&#39; &amp;&amp; typeof message.data === &#39;string&#39;) {
      const data = JSON.parse(message.data) as WSMessage;
      await this.handleWSMessage(data);
    } else if (
      message.type === &#39;binary&#39; &amp;&amp;
      message.data instanceof ArrayBuffer &amp;&amp;
      this.playerService.initialized &amp;&amp;
      this._isAudioOn.value
    ) {
      this.playerService.play(new Int16Array(message.data));
    }
  } catch (error) {
    this.logError(&#39;Error handling WebSocket message:&#39;, error);
  }
}
</code></pre>
<ul>
<li>Differentiates between text and binary WebSocket messages for appropriate processing.</li>
<li>Handles AI-generated audio responses by playing them through the <code class="inline-code">PlayerService</code>.</li>
<li>Demonstrates error resilience by logging and recovering from message handling issues.</li>
</ul>
<hr>
<pre><code class="language-typescript">async toggleRecording(constraints?: MediaStreamConstraints) { 
  try {
    const newRecordingState = await this.handleAudioRecord(this._isRecording.value, constraints);
    this._isRecording.next(newRecordingState);
    return newRecordingState;
  } catch (error) {
    this.logError(&#39;Recording error:&#39;, error);
    this._isRecording.next(false);
    return false;
  }
}
</code></pre>
<ul>
<li>Toggles audio recording state based on current connection and recording status.</li>
<li>Uses the <code class="inline-code">RecorderService</code> to start/stop audio capture and stream data to the server.</li>
<li>Implements error handling for recording failures and resets the recorder state.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Use RxJS observables to track state changes and propagate updates across your application.</li>
<li>Study how <code class="inline-code">WebSocketService</code> differentiates between binary and text messages to handle diverse data types.</li>
<li>Explore the <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/realtime-manager.service.ts#L132" target="_blank" rel="noopener noreferrer"><code class="inline-code">toggleRecording</code></a> method to understand how audio recording integrates with WebSocket communication.</li>
</ul>
<h2>Try This</h2>
<p>Challenge yourself to deepen your understanding:</p>
<ol>
<li><p><strong>Add Connection Retry Logic</strong>: Modify the <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/web-socket.service.ts#L27" target="_blank" rel="noopener noreferrer"><code class="inline-code">connect</code></a> method in <code class="inline-code">WebSocketService</code> to implement automatic reconnection on failure. Use exponential backoff for retry intervals.</p>
<ul>
<li>Example: Start with a 1-second delay and double it on each retry, up to a maximum of 30 seconds.</li>
</ul>
</li>
<li><p><strong>Trace Message Flow</strong>: Add console.log statements to track the complete lifecycle of a WebSocket message. Log when messages are sent, received, and processed within <code class="inline-code">RealTimeManagerService</code>.</p>
</li>
<li><p><strong>Improve Error Feedback</strong>: Enhance the error handling in <code class="inline-code">handleWebSocketMessage</code> to display user-friendly error messages in the UI. Use the <code class="inline-code">_error</code> observable to bind error messages to a notification component.</p>
</li>
</ol>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries of the real-time AI application.</p>
<p>Congratulations on achieving a seamless implementation of client-side real-time coordination‚Äîyour event-driven architecture is now a shining example of low-latency synchronization! üöÄ‚ö°üíé</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-2.html" class="prev-quest-btn">‚Üê Previous: Quest 2</a>
        <a href="quest-4.html" class="next-quest-btn">Next: Quest 4 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>