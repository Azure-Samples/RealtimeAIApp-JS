<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The WebSocket Gatekeeper - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "tk53e05gf2");
    </script>
    
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }

        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-mythical">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/danwahlin/RealtimeAIApp-JS" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Enchanted Kingdom of Realtime AI</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Adventure</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 1: The WebSocket Gatekeeper</h1>
<hr>
<p>In the mystical kingdom, the Enchanted Castle of Realtime AI hums with energy as its magical WebSocket Gatekeeper diligently manages the flow of enchanted messages. This Gatekeeper ensures that knights and healers can communicate seamlessly with the Oracle of Azure OpenAI. The intricate spells of connection and session management are woven into the Gatekeeper‚Äôs core, enabling real-time exchanges of wisdom. Your quest is to uncover the secrets of the WebSocket Gatekeeper and master the art of session orchestration.</p>
<h2>Key Takeaways</h2>
<p>After completing this quest, you will understand:</p>
<ul>
<li>üéØ <strong>WebSocket Upgrade Handling</strong>: How the server upgrades HTTP connections to WebSocket and manages client sessions.</li>
<li>üîç <strong>Session Initialization</strong>: The process of creating a real-time session and configuring it with system messages.</li>
<li>‚ö° <strong>Audio Buffering and Backpressure</strong>: How audio data is batched, buffered, and sent efficiently to handle real-time constraints.</li>
<li>üí° <strong>Error Handling in WebSocket Systems</strong>: Techniques for ensuring stability and graceful degradation during communication failures.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/server.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">server/src/server.ts</code></a></h3>
<p>The <code class="inline-code">server.ts</code> file serves as the entry point for the WebSocket Gatekeeper, transforming ordinary HTTP requests into magical WebSocket connections. It handles client upgrades, initializes sessions, and ensures the flow of data between the client and the Oracle. This file illustrates key patterns for WebSocket management, error handling, and logging.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">server.on(&#39;upgrade&#39;)</code>: Handles HTTP-to-WebSocket upgrades and validates the connection path.</li>
<li><code class="inline-code">wss.on(&#39;connection&#39;)</code>: Manages the lifecycle of WebSocket connections and initializes sessions.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/server.ts#L39" target="_blank" rel="noopener noreferrer"><code class="inline-code">handleSocketEvent</code></a>: Processes WebSocket events such as messages, errors, and closures.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">server.on(&#39;upgrade&#39;, (request, socket, head) =&gt; {
  const { pathname } = new URL(request.url!, `http://${request.headers.host}`);
  if (pathname === &#39;/realtime&#39;) {
    logger.debug({ pathname }, &#39;Handling WebSocket upgrade request&#39;);
    wss.handleUpgrade(request, socket, head, (ws) =&gt; {
      logger.debug(&#39;WebSocket upgrade successful&#39;);
      wss.emit(&#39;connection&#39;, ws, request);
    });
  } else {
    logger.warn({ pathname }, &#39;Invalid WebSocket path - destroying connection&#39;);
    socket.destroy();
  }
});
</code></pre>
<ul>
<li>This code upgrades HTTP requests to WebSocket connections, ensuring only valid paths (<code class="inline-code">/realtime</code>) are processed.</li>
<li>The <code class="inline-code">handleUpgrade</code> method creates a WebSocket connection, while invalid paths are rejected to protect the server.</li>
<li>Logging provides visibility into connection attempts and potential issues.</li>
<li>This ensures secure and efficient handling of client requests.</li>
</ul>
<hr>
<pre><code class="language-typescript">wss.on(&#39;connection&#39;, (ws: WebSocket) =&gt; {
  logger.info(&#39;üü¢ New Client websocket connection opened&#39;);
  let rtSession: RTSession | null = null;

  const handleSocketEvent = (eventType: string, data?: any) =&gt; {
    switch (eventType) {
      case &#39;message&#39;:
        if (!data) {
          logger.warn(&#39;Received empty message&#39;);
          return;
        }

        try {
          const messageText = data.toString();
          const initSystemMessage = JSON.parse(messageText);

          if (initSystemMessage.type === &#39;init&#39;) {
            if (rtSession) {
              logger.warn(&#39;üü† RTSession already exists - ignoring duplicate init&#39;);
              return;
            }

            logger.info(&#39;üîÑ Initializing RTSession&#39;);
            const systemMessage = getSystemMessage(initSystemMessage.systemMessageType);
            logger.info( { systemMessage }, &#39;‚úÖ System message retrieved&#39;);
            
            rtSession = new RTSession(ws, logger, systemMessage);
            ws.off(&#39;message&#39;, messageHandler);
          }
        } catch (error) {
          logger.error({ error, message: data.toString() }, &#39;üî• Failed to process message&#39;);
        }
        break;

      case &#39;error&#39;:
        logger.error({ error: data }, &#39;üî• WebSocket error occurred&#39;);
        rtSession?.dispose();
        rtSession = null;
        break;

      case &#39;close&#39;:
        logger.info(&#39;üî¥ WebSocket connection closed&#39;);
        rtSession?.dispose();
        rtSession = null;
        break;
    }
  };

  const messageHandler = (message: any) =&gt; handleSocketEvent(&#39;message&#39;, message);

  ws.on(&#39;message&#39;, messageHandler);
  ws.on(&#39;error&#39;, (error: Error) =&gt; handleSocketEvent(&#39;error&#39;, error));
  ws.on(&#39;close&#39;, () =&gt; handleSocketEvent(&#39;close&#39;));
});
</code></pre>
<ul>
<li>The <code class="inline-code">connection</code> event initializes a new WebSocket session, assigning a unique <code class="inline-code">RTSession</code> to each client.</li>
<li>The <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/server.ts#L39" target="_blank" rel="noopener noreferrer"><code class="inline-code">handleSocketEvent</code></a> function centralizes event handling, ensuring proper cleanup on errors or closures.</li>
<li>The <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/systemMessages.ts#L90" target="_blank" rel="noopener noreferrer"><code class="inline-code">getSystemMessage</code></a> function retrieves pre-defined AI personality configurations based on the client‚Äôs request.</li>
<li>Logging and error handling ensure the server remains stable even under unexpected conditions.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/session.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">server/src/session.ts</code></a></h3>
<p>The <code class="inline-code">session.ts</code> file is the heart of the WebSocket Gatekeeper, managing real-time sessions between clients and the Oracle. It handles the initialization of connections, buffering of audio data, and efficient communication with the OpenAI Realtime API.</p>
<h4>Highlights</h4>
<ul>
<li><code class="inline-code">RTSession.constructor</code>: Initializes a session with system messages and prepares the WebSocket connections.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/server/src/session.ts#L131" target="_blank" rel="noopener noreferrer"><code class="inline-code">initializeRealtimeWebSocket</code></a>: Establishes a connection to the OpenAI Realtime API with proper authentication.</li>
<li><code class="inline-code">flushAudioBuffer</code>: Efficiently batches and sends audio data, handling backpressure to maintain performance.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">constructor(
  private readonly clientWs: WebSocket,
  private readonly logger: Logger,
  private systemMessage: SystemMessage | null
) {
  if (!this.systemMessage) throw new Error(&#39;üî• System message is required&#39;);

  this.logger = logger.child({ sessionId: this.sessionId });
  this.logger.info({ message: this.systemMessage.message }, &#39;‚úÖ Init message received&#39;);
  this.initialize().catch((error) =&gt; this.logger.error({ error }, &#39;üî• Failed to initialize session&#39;));
}
</code></pre>
<ul>
<li>The constructor initializes the session with a unique ID and system message, ensuring each session is uniquely identifiable.</li>
<li>The <code class="inline-code">logger</code> is enriched with the session ID for better traceability in logs.</li>
<li>The <code class="inline-code">initialize</code> method sets up the connection to the OpenAI Realtime API, ensuring readiness for communication.</li>
</ul>
<hr>
<pre><code class="language-typescript">private async initializeRealtimeWebSocket(): Promise&lt;WebSocket&gt; {
  const url = BACKEND === &#39;azure&#39;
    ? `${OPENAI_ENDPOINT.replace(&#39;https://&#39;, &#39;wss://&#39;)}/openai/realtime?deployment=${OPENAI_MODEL}&amp;api-version=${OPENAI_API_VERSION}`
    : this.openAIWsUrl;

  this.logger.info(`üîå Connecting to OpenAI WebSocket at ${url}`);

  return new Promise(async (resolve, reject) =&gt; {
    const headers = await this.getWebSocketHeaders();
    const openAIWs = new WebSocket(url, { headers });

    openAIWs.on(&#39;open&#39;, () =&gt; {
      this.logger.info(&#39;üü¢ OpenAI WebSocket connection opened&#39;);
      resolve(openAIWs);
    });

    openAIWs.on(&#39;error&#39;, (error) =&gt; {
      console.log(error);
      reject(error);
    });
  });
}
</code></pre>
<ul>
<li>This function establishes a WebSocket connection to the OpenAI Realtime API, dynamically configuring the URL and headers based on the backend (Azure or OpenAI).</li>
<li>Authentication headers are retrieved securely, supporting both API key and managed identity approaches.</li>
<li>The promise-based implementation ensures the connection is fully established before proceeding.</li>
</ul>
<hr>
<pre><code class="language-typescript">private flushAudioBuffer() {
  this.audioBufferTimer = null;

  if (this.audioBufferQueue.length === 0) return;
  if (!this.openAIWs || this.openAIWs.readyState !== WebSocket.OPEN) {
    this.clearAudioQueue();
    return;
  }

  try {
    const bufferedAmount = (this.openAIWs as any)._socket?.bufferedAmount || 0;
    if (this.handleBackpressure(bufferedAmount)) return;

    const totalSize = this.currentBufferSize;
    const combinedBuffer = this.combineAudioBuffers(totalSize);

    if (combinedBuffer.length === 0) {
      this.logger.warn(&#39;Combined buffer is empty after combination. Skipping send.&#39;);
      this.clearAudioQueue();
      return;
    }

    this.clearAudioQueue();
    const sendStart = performance.now();
    this.sendAudioToOpenAI(combinedBuffer, totalSize);
    const sendDuration = performance.now() - sendStart;

    this.updateAudioMetrics(totalSize, sendDuration);
  } catch (error) {
    this.logger.error({ error }, &#39;üî• Error while flushing audio buffer&#39;);
    this.clearAudioQueue();
  }
}
</code></pre>
<ul>
<li>This method batches audio data into a single buffer and sends it to the OpenAI Realtime API, optimizing performance.</li>
<li>Backpressure is handled by monitoring the WebSocket‚Äôs buffered amount and dropping older chunks if necessary.</li>
<li>Metrics such as batch size and send duration are logged for performance monitoring.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Review how the <code class="inline-code">server.on(&#39;upgrade&#39;)</code> method validates WebSocket paths to prevent unauthorized connections.</li>
<li>Examine the <code class="inline-code">flushAudioBuffer</code> method to understand how audio batching improves efficiency in real-time systems.</li>
<li>Trace the lifecycle of a session from initialization to disposal to see how resources are managed.</li>
</ul>
<h2>Try This</h2>
<p>Challenge yourself to deepen your understanding:</p>
<ol>
<li><p><strong>Add a New System Message</strong>: Create a new AI personality in <code class="inline-code">systemMessages</code> for a &quot;Storyteller&quot; mode. Update the <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/player.service.ts#L11" target="_blank" rel="noopener noreferrer"><code class="inline-code">init</code></a> message to support this new mode and observe the system&#39;s behavior.</p>
<ul>
<li>Example: Add a storytelling AI that generates creative narratives based on user prompts.</li>
</ul>
</li>
<li><p><strong>Trace Audio Buffering</strong>: Add logging to the <code class="inline-code">flushAudioBuffer</code> method to track the size of each batch and the number of dropped chunks. Test with varying audio input rates to observe backpressure handling.</p>
</li>
<li><p><strong>Enhance Error Handling</strong>: Modify the WebSocket error handling in <code class="inline-code">RTSession</code> to provide more detailed feedback to clients. For example, include error codes and retry suggestions in the control messages.</p>
</li>
</ol>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries of the Enchanted Castle‚Äôs magical systems.</p>
<p>By the radiant stars of the Celestial Spire, you have unlocked the secrets of &#39;The WebSocket Gatekeeper,&#39; proving yourself a true herald of the digital realms‚Äîforge ahead, brave champion, for the next quest awaits your valor! ‚ö°üíéüöÄ</p>

</div>


      <div class="quest-navigation quest-navigation-bottom nav-next-only">
        <a href="quest-2.html" class="next-quest-btn">Next: Quest 2 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>