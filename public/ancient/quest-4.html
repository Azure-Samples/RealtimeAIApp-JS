<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ritual of Echoing Voices - Repo Adventure</title>
    <link rel="stylesheet" href="assets/theme.css">
    <link rel="stylesheet" href="../assets/shared/quest-navigator.css">
    <link rel="stylesheet" href="../assets/theme-toggle.css">
    
    <script type="text/javascript">
        (function(c,l,a,r,i,t,y){
            c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
            t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
            y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
        })(window, document, "clarity", "script", "tk53e05gf2");
    </script>
    
    <!-- Prism.js for syntax highlighting -->
    <!-- Using minimal theme since we override all styles with our custom theme -->
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Configure Prism autoloader for syntax highlighting
        if (window.Prism && window.Prism.plugins && window.Prism.plugins.autoloader) {
            window.Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
        }

        // Trigger Prism highlighting after page load
        document.addEventListener('DOMContentLoaded', function() {
            if (window.Prism) {
                window.Prism.highlightAll();
            }
        });
    </script>
</head>
<body class="theme-ancient">

    <nav class="navbar">
        <div class="nav-content">
            <div class="nav-left">
                <a href="https://github.com/danwahlin/RealtimeAIApp-JS" target="_blank" rel="noopener noreferrer" class="github-link">
                    <img src="../assets/shared/github-mark-white.svg" alt="GitHub" width="24" height="24">
                </a>
                <a href="index.html">The Temple of Echoes: Ancient Wisdom Unveiled</a>
            </div>
            <div class="nav-middle">
            </div>
            <div class="nav-right">
                <a href="../index.html" class="nav-link">Change Adventure</a>
                <a href="#" class="nav-link quest-map-trigger">Quests</a>
                <button class="theme-toggle-btn" aria-label="Switch to light mode" type="button">
                    <div class="theme-toggle-slider">
                        <svg class="toggle-icon sun-icon" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="4" fill="currentColor"/>
                            <path d="M12 2v2M12 20v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M2 12h2M20 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <svg class="toggle-icon moon-icon" viewBox="0 0 24 24">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                        </svg>
                    </div>
                </button>
            </div>
        </div>
    </nav>
    
    <div class="container">
        <div class="quest-content">
    <h1>Quest 4: The Ritual of Echoing Voices</h1>
<hr>
<p>Deep within the sacred halls of the Temple of Echoes, the Ritual of Echoing Voices is performed‚Äîa ceremony that bridges mortal prayers with divine responses through the mastery of sound. The ancient Whispering Glyphs and Ritual Stones are said to transmute mortal voices into celestial tones, allowing seamless communication. Your journey takes you to the heart of this ritual, where you will uncover the secrets of audio capture and playback. These technologies, represented as sacred artifacts, ensure the voices of the faithful are heard and answered.</p>
<h2>Key Takeaways</h2>
<p>After completing this quest, you will understand:</p>
<ul>
<li>üéØ <strong>Audio Worklets</strong>: How audio processing pipelines convert and manage sound data in real time.</li>
<li>üîç <strong>Recorder Initialization</strong>: The steps to capture audio streams and process them for transmission.</li>
<li>‚ö° <strong>Playback Management</strong>: How to efficiently handle audio buffers for smooth playback experiences.</li>
<li>üí° <strong>Web Audio API</strong>: Practical usage of AudioContext and AudioWorklet for low-latency audio processing.</li>
</ul>
<h2>File Exploration</h2>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/player.service.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">client/src/app/core/player.service.ts</code></a></h3>
<p>The Player Service represents the Ritual Stones of the temple, responsible for playing back the divine responses. This service uses the Web Audio API to manage audio playback, ensuring smooth and efficient delivery of sound. Its design focuses on initializing playback systems, processing audio buffers, and handling playback interruptions gracefully.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/player.service.ts#L11" target="_blank" rel="noopener noreferrer"><code class="inline-code">init</code></a>: Initializes the audio context and sets up the playback worklet for processing audio buffers.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/player.service.ts#L62" target="_blank" rel="noopener noreferrer"><code class="inline-code">play</code></a>: Sends audio data to the playback worklet for real-time playback.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/player.service.ts#L85" target="_blank" rel="noopener noreferrer"><code class="inline-code">clear</code></a>: Clears the audio buffer to prevent overlapping or residual sounds.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">async init(sampleRate: number) {
  if (this.playbackNode === null) {
    this.audioContext = new AudioContext({ sampleRate });
    const playbackWorkletBlobUrl = URL.createObjectURL(new Blob([`
      registerProcessor(&#39;playback-worklet&#39;, class PlaybackProcessor extends AudioWorkletProcessor {
        constructor() {
          super();
          this.port.onmessage = this.handleMessage.bind(this);
          this.buffer = [];
        }
        handleMessage(event) {
          if (event.data === null) {
            this.buffer = [];
            return;
          }
          this.buffer.push(...event.data);
        }
        process(inputs, outputs, parameters) {
          const output = outputs[0];
          const channel = output[0];
          if (this.buffer.length &gt; channel.length) {
            const toProcess = this.buffer.splice(0, channel.length);
            channel.set(toProcess.map((v) =&gt; v / 32768));
          } else {
            channel.set(this.buffer.map((v) =&gt; v / 32768));
            this.buffer = [];
          }
          return true;
        }
      });
    `], { type: &#39;application/javascript&#39; }));
    await this.audioContext.audioWorklet.addModule(playbackWorkletBlobUrl);
    setTimeout(() =&gt; {
      if (this.audioContext &amp;&amp; !this.initialized) {
        this.playbackNode = new AudioWorkletNode(this.audioContext, &#39;playback-worklet&#39;);
        this.playbackNode.connect(this.audioContext.destination);
        this.initialized = true;
      }
    }, 100);
  }
}
</code></pre>
<ul>
<li>This code initializes an AudioContext with a custom AudioWorklet for playback.</li>
<li>The use of <code class="inline-code">AudioWorkletProcessor</code> enables efficient low-latency audio processing.</li>
<li>The buffer system ensures smooth playback by managing audio chunks dynamically.</li>
<li>The modular design allows reusability and easy debugging.</li>
<li>The delayed initialization ensures the browser properly loads the worklet.</li>
</ul>
<hr>
<pre><code class="language-typescript">async play(buffer: Int16Array) {
  if (!this.playbackNode || !this.audioContext) {
    console.warn(&#39;Audio not initialized&#39;);
    return;
  }
  if (this.audioContext.state === &#39;suspended&#39;) {
    await this.audioContext.resume();
  }
  if (buffer &amp;&amp; buffer.length &gt; 0) {
    try {
      this.playbackNode.port.postMessage(buffer);
    } catch (error) {
      console.error(&#39;Failed to play audio:&#39;, error);
    }
  } else {
    console.warn(&#39;Empty or invalid audio buffer received so unable to play the audio&#39;);
  }
}
</code></pre>
<ul>
<li>The <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/player.service.ts#L62" target="_blank" rel="noopener noreferrer"><code class="inline-code">play</code></a> method sends audio data to the playback worklet for real-time processing.</li>
<li>It ensures that the audio context is active before playback begins.</li>
<li>Error handling provides robustness by logging playback issues.</li>
<li>The design supports dynamic audio input for uninterrupted user experiences.</li>
</ul>
<hr>
<h3><span class="header-prefix">File:</span> <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/recorder.service.ts" target="_blank" rel="noopener noreferrer"><code class="inline-code">client/src/app/core/recorder.service.ts</code></a></h3>
<p>The Recorder Service serves as the Whispering Glyphs, capturing mortal voices and transmuting them into a format suitable for divine transmission. This service manages audio input streams, converts them to a usable format, and ensures efficient handling of audio data.</p>
<h4>Highlights</h4>
<ul>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/recorder.service.ts#L26" target="_blank" rel="noopener noreferrer"><code class="inline-code">start</code></a>: Initializes the recorder, connects the audio stream, and processes input audio.</li>
<li><code class="inline-code">RecorderPCMProcessor</code>: Converts Float32 audio data to Int16 for compatibility with the server.</li>
<li><a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/recorder.service.ts#L139" target="_blank" rel="noopener noreferrer"><code class="inline-code">reset</code></a>: Stops and resets the recorder, ensuring no residual state.</li>
</ul>
<h4>Code</h4>
<pre><code class="language-typescript">async start(stream: MediaStream) {
  if (this.isRecording) {
    console.warn(&#39;Recording already in progress. Ignoring new start call.&#39;);
    return;
  }
  this.isRecording = true;
  try {
    this.mediaStream = stream;
    if (!this.audioContext || this.audioContext.state === &#39;closed&#39;) {
      this.audioContext = new AudioContext({
        latencyHint: &#39;interactive&#39;,
        sampleRate: 24000,
      });
    }
    this.mediaStreamSource = this.audioContext.createMediaStreamSource(this.mediaStream);
    if (!this.workletBlobUrl) {
      this.workletBlobUrl = URL.createObjectURL(new Blob([`
        registerProcessor(&#39;recorder-worklet&#39;, class RecorderPCMProcessor extends AudioWorkletProcessor {
          constructor() {
            super();
          }
          process(inputs) {
            const input = inputs[0];
            if (input.length &gt; 0) {
              const float32Buffer = input[0];
              const int16Buffer = this.convertFloat32ToInt16(float32Buffer);
              this.port.postMessage(int16Buffer);
            }
            return true;
          }
          convertFloat32ToInt16(float32Array) {
            const int16Array = new Int16Array(float32Array.length);
            for (let i = 0; i &lt; float32Array.length; i++) {
              let val = Math.floor(float32Array[i] * 0x7fff);
              val = Math.max(-0x8000, Math.min(0x7fff, val));
              int16Array[i] = val;
            }
            return int16Array;
          }
        });
      `], { type: &#39;application/javascript&#39; }));
    }
    if (!this.workletNode) {
      await this.audioContext.audioWorklet.addModule(this.workletBlobUrl);
    }
    this.workletNode = new AudioWorkletNode(this.audioContext, &#39;recorder-worklet&#39;, {
      numberOfInputs: 1,
      numberOfOutputs: 1,
      channelCount: 1,
      processorOptions: { sampleRate: this.audioContext.sampleRate },
    });
    this.workletNode.port.onmessage = (event) =&gt; {
      if (this.onDataAvailable) {
        this.onDataAvailable(event.data);
      }
    };
    this.mediaStreamSource.connect(this.workletNode);
    this.workletNode.connect(this.audioContext.destination);
  } catch (error) {
    console.error(&#39;Error starting recorder:&#39;, error);
    this.stop();
  }
}
</code></pre>
<ul>
<li>The <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/recorder.service.ts#L26" target="_blank" rel="noopener noreferrer"><code class="inline-code">start</code></a> method initializes the audio stream and connects it to a custom AudioWorklet.</li>
<li>It uses <code class="inline-code">MediaStream</code> to capture audio directly from the user&#39;s microphone.</li>
<li>The worklet converts Float32 audio data to Int16, a format suitable for transmission.</li>
<li>The modular design allows for reusability and efficient error handling.</li>
<li>This approach ensures low-latency audio capture for real-time applications.</li>
</ul>
<hr>
<pre><code class="language-typescript">reset() {
  console.log(&quot;Recorder Reset called&quot;);
  this.stop();
  this.onDataAvailable = (buffer) =&gt; {
    console.warn(&#39;onDataAvailable default called. No callback set in component.&#39;);
  };
  if (this.audioContext &amp;&amp; this.audioContext.state !== &#39;closed&#39;) {
    this.audioContext.close();
    this.audioContext = null;
  }
}
</code></pre>
<ul>
<li>The <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/recorder.service.ts#L139" target="_blank" rel="noopener noreferrer"><code class="inline-code">reset</code></a> method stops the recorder and resets its state.</li>
<li>It ensures that no residual audio connections or callbacks remain active.</li>
<li>The method provides a clean slate for reinitialization, preventing resource leaks.</li>
<li>The use of logging aids in debugging and monitoring recorder behavior.</li>
</ul>
<hr>
<h2>Helpful Hints</h2>
<ul>
<li>Study how <code class="inline-code">AudioWorkletProcessor</code> is used for low-latency audio processing.</li>
<li>Observe the modular design of both services, which allows easy debugging and testing.</li>
<li>Experiment with different sample rates to understand their impact on audio quality and performance.</li>
</ul>
<h2>Try This</h2>
<p>Challenge yourself to deepen your understanding:</p>
<ol>
<li><strong>Modify Buffer Size</strong>: Adjust the audio buffer size in the <code class="inline-code">PlaybackProcessor</code> and observe how it affects playback smoothness. This will help you understand the trade-offs between latency and buffer management.</li>
<li><strong>Implement Audio Filters</strong>: Add an audio filter (e.g., low-pass filter) to the <code class="inline-code">RecorderPCMProcessor</code> to preprocess the audio before sending it. This will teach you how to manipulate audio streams dynamically.</li>
<li><strong>Simulate Network Latency</strong>: Introduce artificial delays in the <a href="https://github.com/danwahlin/RealtimeAIApp-JS/blob/main/client/src/app/core/player.service.ts#L62" target="_blank" rel="noopener noreferrer"><code class="inline-code">play</code></a> method and observe the impact on user experience. This exercise will highlight the importance of efficient audio handling in real-time systems.</li>
</ol>
<hr>
<p>Excellent work! Continue to the next quest to uncover more mysteries of the Temple of Echoes.</p>
<p>By the sacred fires of the ancients, thou hast unlocked the voices of eternity, forging thy path through the hallowed halls of wisdom‚Äîpress on, seeker, for the stars yet await thy ascension! ‚≠êüíé‚ö°</p>

</div>


      <div class="quest-navigation quest-navigation-bottom">
        <a href="quest-3.html" class="prev-quest-btn">‚Üê Previous: Quest 3</a>
        <a href="quest-5.html" class="next-quest-btn">Next: Quest 5 ‚Üí</a>
      </div>
    
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <span>Created using <a href="https://github.com/DanWahlin/ai-repo-adventures" target="_blank" rel="noopener noreferrer" class="repo-link">AI Repo Adventures</a></span>
        </div>
    </footer>
    
    <!-- Quest Navigator Script (for navbar Quests button functionality) -->
    <script src="../assets/shared/quest-navigator.js"></script>
    <!-- Theme Toggle Script (for light/dark mode toggle) -->
    <script src="../assets/theme-toggle.js"></script>
</body>
</html>